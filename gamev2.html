<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Mängulaud</title>
		<style>
			body {
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				height: 100vh;
				margin: 0;
			}
			table {
				border-collapse: collapse;
			}
			td {
				width: 80px;
				height: 80px;
				text-align: center;
				vertical-align: middle;
				font-size: 20px;
				font-family: Arial, sans-serif;
				position: relative;
				cursor: pointer;
			}
			.even {
				background-color: white;
				border: 1px solid;
			}
			.odd {
				background-color: grey;
				border: 1px solid;
			}
			.empty {
				visibility: hidden;
			}
			.selected {
				background-color: yellow !important;
			}
			#position-display {
				margin-top: 20px;
				font-size: 18px;
				font-family: Arial, sans-serif;
			}
			.finishline {
				font-size: 40px;
				border: 1px solid;
			}
			.startline {
				font-size: 40px;
				border: 1px solid;
			}
			.ai {
				background-color: red !important;
			}
		</style>
	</head>
	<body>
		<div id="game-container"></div>
		<div id="position-display"></div>
		<script>
			const squares = document.querySelectorAll("td");
			const positionDisplay = document.getElementById("position-display");

			function generateGrid(rows, cols) {
				const gameContainer = document.getElementById("game-container");
				const table = document.createElement("table");

				const startRow = document.createElement("tr");
				const startCell = document.createElement("td");
				startCell.textContent = "START";
				startCell.classList.add("startline", "selected");
				startCell.colSpan = cols;
				startCell.dataset.x = 0;
				startCell.dataset.y = 0;
				startCell.style.pointerEvents = "auto";
				startCell.addEventListener("click", handleCellClick);
				startRow.appendChild(startCell);
				table.appendChild(startRow);

				let number = 1;
				let bottomNumber = 2;
				maxY = rows + 1;

				for (let y = 1; y <= rows; y++) {
					const row = document.createElement("tr");

					for (let x = 1; x <= cols; x++) {
						const cell = document.createElement("td");

						cell.dataset.x = x;
						cell.dataset.y = y;

						if (y % 2 === 1) {
							if (x % 2 === 0) {
								cell.textContent = number;
								cell.classList.add("odd");
								cell.style.pointerEvents = "auto";
								number += 2;
							} else {
								cell.textContent = "-";
								cell.classList.add("empty");
								cell.style.pointerEvents = "none";
							}
						} else {
							if (x % 2 === 1) {
								cell.textContent = bottomNumber;
								cell.classList.add("even");
								cell.style.pointerEvents = "auto";
								bottomNumber += 2;
							} else {
								cell.textContent = "-";
								cell.classList.add("empty");
								cell.style.pointerEvents = "none";
							}
						}

						cell.addEventListener("click", handleCellClick);

						row.appendChild(cell);
					}

					table.appendChild(row);
				}

				const finishRow = document.createElement("tr");
				const finishCell = document.createElement("td");
				finishCell.textContent = "FINISH";
				finishCell.classList.add("finishline");
				finishCell.colSpan = cols;
				finishCell.dataset.x = 0;
				finishCell.dataset.y = maxY;
				finishCell.style.pointerEvents = "auto";
				finishCell.addEventListener("click", handleCellClick);
				finishRow.appendChild(finishCell);
				table.appendChild(finishRow);

				gameContainer.appendChild(table);

				positionDisplay.innerHTML = `
        <div>Score: ${score.toFixed(0)} | Multiplier: ${scoreMultiplier.toFixed(2)}x</div>
        Alustamiseks liigu esimese või teise rea ruudule, mis järgneb START reale.
    `;
			}

			let aiPosition = null;
			let aiInitialized = false;
			let maxY;
			let score = 0; // Track the player's score
			let scoreMultiplier = 1.0; // Start multiplier at 1.0x
			let hasFinished = false;

			function highlightAISquare(playerSquare) {
				const playerX = parseInt(playerSquare.dataset.x, 10);
				const playerY = parseInt(playerSquare.dataset.y, 10);

				if (!aiInitialized) {
					let targetX = playerX;
					let targetY = playerY + 2;

					if (playerY + 2 >= maxY) {
						targetY = playerY - 2;
					}

					console.log("Target AI Position:", { targetX, targetY });

					const targetSquare = document.querySelector(`td[data-x="${targetX}"][data-y="${targetY}"]`);
					if (targetSquare && !targetSquare.classList.contains("empty")) {
						targetSquare.classList.add("ai");
						aiPosition = { x: targetX, y: targetY };
						aiInitialized = true;
						console.log("AI placed at:", aiPosition);
					} else {
						console.log("Target square is invalid or empty");
					}
				} else if (aiPosition) {
					moveAI(playerSquare); // Handle subsequent AI movements
				}
			}

			function moveAI(playerSquare) {
				const playerX = parseInt(playerSquare.dataset.x, 10);
				const playerY = parseInt(playerSquare.dataset.y, 10);

				const aiX = aiPosition.x;
				const aiY = aiPosition.y;

				// Helper function to find valid neighbors (cells that AI can move to)
				function getValidNeighbors(x, y) {
					const neighbors = [];
					const directions = [
						{ dx: 1, dy: 1 }, // down-right
						{ dx: -1, dy: 1 }, // down-left
						{ dx: 1, dy: -1 }, // up-right
						{ dx: -1, dy: -1 }, // up-left
					];

					for (const { dx, dy } of directions) {
						const newX = x + dx;
						const newY = y + dy;

						// Check if the new position is within bounds and not an empty square
						const neighborSquare = document.querySelector(`td[data-x="${newX}"][data-y="${newY}"]`);
						if (neighborSquare && !neighborSquare.classList.contains("empty")) {
							neighbors.push({ x: newX, y: newY });
						}
					}

					return neighbors;
				}

				// BFS function to find the shortest path
				function bfs(startX, startY, targetX, targetY) {
					const queue = [{ x: startX, y: startY, path: [] }];
					const visited = new Set();
					visited.add(`${startX},${startY}`);

					while (queue.length > 0) {
						const { x, y, path } = queue.shift();

						// If we've reached the target, return the path
						if (x === targetX && y === targetY) {
							return path;
						}

						const neighbors = getValidNeighbors(x, y);
						for (const { x: nx, y: ny } of neighbors) {
							const pos = `${nx},${ny}`;
							if (!visited.has(pos)) {
								visited.add(pos);
								queue.push({ x: nx, y: ny, path: [...path, { x: nx, y: ny }] });
							}
						}
					}

					return []; // No path found
				}

				// Get the shortest path from AI to the player
				const pathToPlayer = bfs(aiX, aiY, playerX, playerY);

				// If there's a valid path, move AI along that path
				if (pathToPlayer.length > 0) {
					const nextMove = pathToPlayer[0]; // The first move in the path is the best move
					const aiSquare = document.querySelector(`td[data-x="${nextMove.x}"][data-y="${nextMove.y}"]`);

					if (aiSquare) {
						// Remove AI from its old position
						const oldAISquare = document.querySelector(`td[data-x="${aiX}"][data-y="${aiY}"]`);
						if (oldAISquare) {
							oldAISquare.classList.remove("ai");
						}

						// Place AI at the new position
						aiSquare.classList.add("ai");
						aiPosition = { x: nextMove.x, y: nextMove.y };

						// Check if the AI catches the player
						if (nextMove.x === playerX && nextMove.y === playerY) {
							resetGame(aiSquare); // Reset the game if the AI catches the player
						}

						console.log("AI moved to:", aiPosition);
					}
				} else {
					console.log("No valid path found for AI.");
				}
			}

			function resetGame(catchSquare) {
				// Reset AI and player state
				aiInitialized = false;
				aiPosition = null;

				score = 0; // Reset score
				scoreMultiplier = 1.0;

				// Remove the .ai class from the square where the player was caught
				if (catchSquare) {
					catchSquare.classList.remove("ai");
				}

				// Reset player to start square
				const currentPlayerSquare = document.querySelector(".selected");
				const startSquare = document.querySelector(`td[data-x="0"][data-y="0"]`);

				if (currentPlayerSquare) {
					currentPlayerSquare.classList.remove("selected");
				}
				if (startSquare) {
					startSquare.classList.add("selected");
					updatePositionDisplay(startSquare);
				}

				// Reset position display text
				positionDisplay.innerHTML = `
        <div>Score: ${score.toFixed(0)} | Multiplier: ${scoreMultiplier.toFixed(2)}x</div>
        Alustamiseks liigu esimese või teise rea ruudule, mis järgneb START reale.
    `;
			}

			function handleCellClick(event) {
				const currentSquare = document.querySelector(".selected");
				const newSquare = event.target;

				if (newSquare.classList.contains("startline") || newSquare.classList.contains("finishline")) {
					if (currentSquare) {
						currentSquare.classList.remove("selected");
					}
					newSquare.classList.add("selected");
					updatePositionDisplay(newSquare);

					if (newSquare.classList.contains("finishline") && !hasFinished) {
						hasFinished = true;
						// Give points the first time crossing finish
						score += 10 * scoreMultiplier;
						scoreMultiplier += 0.2; // Increase multiplier
						positionDisplay.innerHTML = `
                <div>Score: ${score.toFixed(0)} | Multiplier: ${scoreMultiplier.toFixed(2)}x</div>
            `;
					} else if (newSquare.classList.contains("startline") && hasFinished) {
						// If player returns to start after finishing, score points
						score += 10 * scoreMultiplier;
						scoreMultiplier += 0.2; // Increase multiplier
						positionDisplay.innerHTML = `
                <div>Score: ${score.toFixed(0)} | Multiplier: ${scoreMultiplier.toFixed(2)}x</div>
            `;
						hasFinished = false; // Reset after scoring
					}

					if (aiPosition) {
						const oldAISquare = document.querySelector(`td[data-x="${aiPosition.x}"][data-y="${aiPosition.y}"]`);
						if (oldAISquare) {
							oldAISquare.classList.remove("ai");
						}
					}

					aiInitialized = false;
					aiPosition = null;

					highlightAISquare(newSquare);
				} else {
					// Validate if the move is allowed
					if (isValidMove(currentSquare, newSquare)) {
						if (currentSquare) {
							currentSquare.classList.remove("selected");
						}
						newSquare.classList.add("selected");
						updatePositionDisplay(newSquare);

						// Check for collision before moving the AI
						if (aiPosition) {
							const aiSquare = document.querySelector(`td[data-x="${aiPosition.x}"][data-y="${aiPosition.y}"]`);
							if (aiSquare && aiSquare === newSquare) {
								resetGame(aiSquare); // Player is caught, reset the game
								return;
							}
						}

						// Move AI if it has been initialized
						if (aiPosition) {
							moveAI(newSquare); // Allow AI to move after the player
						} else {
							highlightAISquare(newSquare); // Initialize AI if not already done
						}
					} else {
						alert("Sa saad liikuda ainult paremale, vasakule, üles või alla.");
					}
				}
			}

			function isValidMove(current, target) {
				const currX = parseInt(current.dataset.x, 10);
				const currY = parseInt(current.dataset.y, 10);
				const targetX = parseInt(target.dataset.x, 10);
				const targetY = parseInt(target.dataset.y, 10);

				if (currY === 0 && (targetY === 1 || targetY === 2)) {
					return true;
				} else if ((currY === 1 || currY === 2) && targetY === 0) {
					return true;
				} else if ((currY === maxY - 1 || currY === maxY - 2) && targetY === maxY) {
					return true;
				} else if (currY === maxY && (targetY === maxY - 1 || targetY === maxY - 2)) {
					return true;
				} else if ((currX === targetX && Math.abs(currY - targetY) === 2) || (currY === targetY && Math.abs(currX - targetX) === 2)) {
					return true;
				} else {
					return false;
				}
			}

			function updatePositionDisplay(square) {
				const x = square.dataset.x;
				const y = square.dataset.y;
				const value = square.textContent;

				// Display current position and score/multiplier
				positionDisplay.textContent = `Asukoht: (${x}; ${y}) ruut ${value} | Score: ${score.toFixed(0)} | Multiplier: ${scoreMultiplier.toFixed(2)}x`;
			}

			generateGrid(6, 7);
		</script>
	</body>
</html>
